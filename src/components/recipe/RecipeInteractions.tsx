import React, {useState, useCallback} from 'react';\nimport {View, StyleSheet} from 'react-native';\nimport {\n  Text,\n  Card,\n  SegmentedButtons,\n  Button,\n  IconButton,\n  Badge,\n} from 'react-native-paper';\nimport {\n  Recipe,\n  RecipeRating,\n  RecipeNote,\n  RecipeVersion,\n  CreateRecipeRatingInput,\n  CreateRecipeNoteInput,\n  CreateRecipeVersionInput,\n} from '@/types';\nimport {useAppSelector} from '@/store';\nimport {\n  useGetUserRatingQuery,\n  useCreateRatingMutation,\n  useUpdateRatingMutation,\n  useGetRecipeNotesQuery,\n  useCreateNoteMutation,\n  useUpdateNoteMutation,\n  useDeleteNoteMutation,\n  useToggleNotePrivacyMutation,\n  useGetRecipeVersionsQuery,\n  useCreateVersionMutation,\n  useRestoreVersionMutation,\n  useDeleteVersionMutation,\n} from '@/services/ratingsApi';\nimport StarRating from './StarRating';\nimport RecipeNotes from './RecipeNotes';\nimport RecipeVersionHistory from './RecipeVersionHistory';\nimport CreateVersionModal from './CreateVersionModal';\nimport {theme} from '@/utils/theme';\n\ninterface RecipeInteractionsProps {\n  recipe: Recipe;\n  onRecipeUpdate?: (recipe: Recipe) => void;\n  style?: any;\n}\n\nconst RecipeInteractions: React.FC<RecipeInteractionsProps> = ({\n  recipe,\n  onRecipeUpdate,\n  style,\n}) => {\n  const {user} = useAppSelector(state => state.auth);\n  const [activeTab, setActiveTab] = useState('rating');\n  const [createVersionModalVisible, setCreateVersionModalVisible] = useState(false);\n  const [selectedBaseVersion, setSelectedBaseVersion] = useState<RecipeVersion | undefined>();\n\n  // API hooks\n  const {\n    data: userRating,\n    refetch: refetchUserRating,\n  } = useGetUserRatingQuery(\n    {recipeId: recipe.id, userId: user?.id || ''},\n    {skip: !user?.id}\n  );\n\n  const {\n    data: notes = [],\n    refetch: refetchNotes,\n  } = useGetRecipeNotesQuery(\n    {recipeId: recipe.id, userId: user?.id, includePrivate: true},\n    {skip: !user?.id}\n  );\n\n  const {\n    data: versions = [],\n    refetch: refetchVersions,\n  } = useGetRecipeVersionsQuery(recipe.id);\n\n  // Mutations\n  const [createRating, {isLoading: isCreatingRating}] = useCreateRatingMutation();\n  const [updateRating, {isLoading: isUpdatingRating}] = useUpdateRatingMutation();\n  const [createNote, {isLoading: isCreatingNote}] = useCreateNoteMutation();\n  const [updateNote, {isLoading: isUpdatingNote}] = useUpdateNoteMutation();\n  const [deleteNote, {isLoading: isDeletingNote}] = useDeleteNoteMutation();\n  const [toggleNotePrivacy] = useToggleNotePrivacyMutation();\n  const [createVersion, {isLoading: isCreatingVersion}] = useCreateVersionMutation();\n  const [restoreVersion] = useRestoreVersionMutation();\n  const [deleteVersion] = useDeleteVersionMutation();\n\n  // Handlers\n  const handleRatingChange = useCallback(async (rating: number) => {\n    if (!user) return;\n\n    try {\n      if (userRating) {\n        await updateRating({\n          id: userRating.id,\n          rating,\n        }).unwrap();\n      } else {\n        const ratingData: CreateRecipeRatingInput = {\n          recipeId: recipe.id,\n          userId: user.id,\n          rating,\n        };\n        await createRating(ratingData).unwrap();\n      }\n      refetchUserRating();\n    } catch (error) {\n      console.error('Error saving rating:', error);\n    }\n  }, [user, userRating, recipe.id, createRating, updateRating, refetchUserRating]);\n\n  const handleAddNote = useCallback(async (noteData: CreateRecipeNoteInput) => {\n    try {\n      await createNote(noteData).unwrap();\n      refetchNotes();\n    } catch (error) {\n      console.error('Error creating note:', error);\n    }\n  }, [createNote, refetchNotes]);\n\n  const handleUpdateNote = useCallback(async (noteId: string, content: string) => {\n    try {\n      await updateNote({id: noteId, content}).unwrap();\n      refetchNotes();\n    } catch (error) {\n      console.error('Error updating note:', error);\n    }\n  }, [updateNote, refetchNotes]);\n\n  const handleDeleteNote = useCallback(async (noteId: string) => {\n    try {\n      await deleteNote(noteId).unwrap();\n      refetchNotes();\n    } catch (error) {\n      console.error('Error deleting note:', error);\n    }\n  }, [deleteNote, refetchNotes]);\n\n  const handleToggleNotePrivacy = useCallback(async (noteId: string, isPrivate: boolean) => {\n    try {\n      await toggleNotePrivacy({id: noteId, isPrivate}).unwrap();\n      refetchNotes();\n    } catch (error) {\n      console.error('Error toggling note privacy:', error);\n    }\n  }, [toggleNotePrivacy, refetchNotes]);\n\n  const handleCreateVersion = useCallback((baseVersionId?: string) => {\n    const baseVersion = baseVersionId \n      ? versions.find(v => v.id === baseVersionId)\n      : undefined;\n    setSelectedBaseVersion(baseVersion);\n    setCreateVersionModalVisible(true);\n  }, [versions]);\n\n  const handleSaveVersion = useCallback(async (versionData: CreateRecipeVersionInput) => {\n    try {\n      await createVersion(versionData).unwrap();\n      refetchVersions();\n      setCreateVersionModalVisible(false);\n      setSelectedBaseVersion(undefined);\n    } catch (error) {\n      console.error('Error creating version:', error);\n    }\n  }, [createVersion, refetchVersions]);\n\n  const handleRestoreVersion = useCallback(async (versionId: string) => {\n    try {\n      await restoreVersion(versionId).unwrap();\n      refetchVersions();\n      // Optionally refresh the recipe data\n      if (onRecipeUpdate) {\n        // This would need to be implemented to fetch the updated recipe\n        // onRecipeUpdate(updatedRecipe);\n      }\n    } catch (error) {\n      console.error('Error restoring version:', error);\n    }\n  }, [restoreVersion, refetchVersions, onRecipeUpdate]);\n\n  const handleDeleteVersion = useCallback(async (versionId: string) => {\n    try {\n      await deleteVersion(versionId).unwrap();\n      refetchVersions();\n    } catch (error) {\n      console.error('Error deleting version:', error);\n    }\n  }, [deleteVersion, refetchVersions]);\n\n  const handleViewVersion = useCallback((version: RecipeVersion) => {\n    // TODO: Navigate to version view or show version details modal\n    console.log('View version:', version);\n  }, []);\n\n  const handleCompareVersions = useCallback((version1Id: string, version2Id: string) => {\n    // TODO: Navigate to version comparison view\n    console.log('Compare versions:', version1Id, version2Id);\n  }, []);\n\n  // Tab configuration\n  const tabs = [\n    {\n      value: 'rating',\n      label: 'Avaliação',\n      icon: 'star',\n      badge: userRating ? '1' : undefined,\n    },\n    {\n      value: 'notes',\n      label: 'Anotações',\n      icon: 'note-text',\n      badge: notes.length > 0 ? notes.length.toString() : undefined,\n    },\n    {\n      value: 'versions',\n      label: 'Versões',\n      icon: 'history',\n      badge: versions.length > 0 ? versions.length.toString() : undefined,\n    },\n  ];\n\n  const renderTabContent = () => {\n    switch (activeTab) {\n      case 'rating':\n        return (\n          <Card style={styles.tabContent}>\n            <Card.Content>\n              <View style={styles.ratingSection}>\n                <Text variant=\"titleMedium\" style={styles.sectionTitle}>\n                  Sua Avaliação\n                </Text>\n                <StarRating\n                  rating={userRating?.rating || 0}\n                  onRatingChange={handleRatingChange}\n                  size=\"large\"\n                  showLabel\n                  style={styles.rating}\n                />\n                {userRating && (\n                  <Text variant=\"bodySmall\" style={styles.ratingDate}>\n                    Avaliado em {new Date(userRating.createdAt).toLocaleDateString('pt-BR')}\n                  </Text>\n                )}\n              </View>\n              \n              <View style={styles.recipeRatingSection}>\n                <Text variant=\"titleMedium\" style={styles.sectionTitle}>\n                  Avaliação Geral\n                </Text>\n                <StarRating\n                  rating={recipe.rating || 0}\n                  readonly\n                  size=\"medium\"\n                  showCount\n                  reviewCount={recipe.reviewCount || 0}\n                  style={styles.recipeRating}\n                />\n              </View>\n            </Card.Content>\n          </Card>\n        );\n\n      case 'notes':\n        return (\n          <RecipeNotes\n            recipeId={recipe.id}\n            notes={notes}\n            onAddNote={handleAddNote}\n            onUpdateNote={handleUpdateNote}\n            onDeleteNote={handleDeleteNote}\n            onTogglePrivate={handleToggleNotePrivacy}\n            loading={isCreatingNote || isUpdatingNote || isDeletingNote}\n          />\n        );\n\n      case 'versions':\n        return (\n          <RecipeVersionHistory\n            recipe={recipe}\n            versions={versions}\n            onCreateVersion={handleCreateVersion}\n            onRestoreVersion={handleRestoreVersion}\n            onDeleteVersion={handleDeleteVersion}\n            onViewVersion={handleViewVersion}\n            onCompareVersions={handleCompareVersions}\n            loading={isCreatingVersion}\n          />\n        );\n\n      default:\n        return null;\n    }\n  };\n\n  if (!user) {\n    return (\n      <Card style={[styles.container, style]}>\n        <Card.Content style={styles.loginPrompt}>\n          <Text variant=\"bodyMedium\" style={styles.loginText}>\n            Faça login para avaliar, fazer anotações e criar versões desta receita\n          </Text>\n          <Button mode=\"contained\" style={styles.loginButton}>\n            Fazer Login\n          </Button>\n        </Card.Content>\n      </Card>\n    );\n  }\n\n  return (\n    <View style={[styles.container, style]}>\n      {/* Tab Navigation */}\n      <View style={styles.tabNavigation}>\n        <SegmentedButtons\n          value={activeTab}\n          onValueChange={setActiveTab}\n          buttons={tabs.map(tab => ({\n            value: tab.value,\n            label: tab.label,\n            icon: tab.icon,\n            showSelectedCheck: false,\n          }))}\n          style={styles.segmentedButtons}\n        />\n        \n        {/* Tab Badges */}\n        <View style={styles.tabBadges}>\n          {tabs.map((tab, index) => {\n            if (!tab.badge) return <View key={tab.value} style={styles.badgeSpace} />;\n            \n            return (\n              <View key={tab.value} style={styles.badgeContainer}>\n                <Badge\n                  visible={!!tab.badge}\n                  style={[\n                    styles.badge,\n                    activeTab === tab.value && styles.activeBadge,\n                  ]}>\n                  {tab.badge}\n                </Badge>\n              </View>\n            );\n          })}\n        </View>\n      </View>\n\n      {/* Tab Content */}\n      {renderTabContent()}\n\n      {/* Create Version Modal */}\n      <CreateVersionModal\n        visible={createVersionModalVisible}\n        onDismiss={() => {\n          setCreateVersionModalVisible(false);\n          setSelectedBaseVersion(undefined);\n        }}\n        onSave={handleSaveVersion}\n        recipe={recipe}\n        baseVersion={selectedBaseVersion}\n        loading={isCreatingVersion}\n      />\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  tabNavigation: {\n    position: 'relative',\n    marginBottom: 16,\n  },\n  segmentedButtons: {\n    backgroundColor: theme.colors.surface,\n  },\n  tabBadges: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    height: '100%',\n    flexDirection: 'row',\n    alignItems: 'flex-start',\n    paddingTop: 8,\n    paddingHorizontal: 8,\n    pointerEvents: 'none',\n  },\n  badgeContainer: {\n    flex: 1,\n    alignItems: 'center',\n  },\n  badgeSpace: {\n    flex: 1,\n  },\n  badge: {\n    backgroundColor: theme.colors.error,\n  },\n  activeBadge: {\n    backgroundColor: theme.colors.primary,\n  },\n  tabContent: {\n    flex: 1,\n    elevation: 1,\n  },\n  ratingSection: {\n    alignItems: 'center',\n    paddingVertical: 16,\n    borderBottomWidth: 1,\n    borderBottomColor: theme.colors.outline + '20',\n    marginBottom: 16,\n  },\n  sectionTitle: {\n    fontWeight: 'bold',\n    color: theme.colors.primary,\n    marginBottom: 12,\n  },\n  rating: {\n    marginBottom: 8,\n  },\n  ratingDate: {\n    opacity: 0.7,\n  },\n  recipeRatingSection: {\n    alignItems: 'center',\n  },\n  recipeRating: {\n    // Additional styling if needed\n  },\n  loginPrompt: {\n    alignItems: 'center',\n    paddingVertical: 32,\n  },\n  loginText: {\n    textAlign: 'center',\n    marginBottom: 16,\n    opacity: 0.7,\n    lineHeight: 20,\n  },\n  loginButton: {\n    minWidth: 120,\n  },\n});\n\nexport default RecipeInteractions;